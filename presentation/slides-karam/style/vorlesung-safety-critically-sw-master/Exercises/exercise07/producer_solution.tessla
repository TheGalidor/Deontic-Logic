include "/usr/local/opt/tessla_rv/streams.tessla"
include "stdlib.tessla"

# a) Generate an event stream with an event for every call of
# produce and another event stream with an event for every return
# of that function

def generateCall := function_call("generate")
def generateReturn := function_return("generate")

out generateCall
out generateReturn

# b) Compute the runtime of produce on every return of that
# function

def generateRuntime := on(
  time(generateReturn) - time(generateCall), generateReturn)
out generateRuntime

# c) Compute the average runtime of produce

def avgRuntime := sum(generateRuntime) / count(generateRuntime)
out avgRuntime

def sum(x: Events[Int]) := {
  def s: Events[Int] := merge(last(s, x), 0) + x
  return s
}

def count[A](x: Events[A]) := {
  def c: Events[Int] := merge(last(c, x) + 1, 0)
  return c
}

# d) Compute the number of generated but not processed messages

def processCall := function_call("process")
def numOpen := count(generateCall) - count(processCall)
out numOpen

# e) Instrument the C program so that we can access the message
# IDs generated by generate and passed to process

def generate := if debug_slot == 1 then debug_value
def process := if debug_slot == 2 then debug_value

out generate
out process

# f) Check that generate produces strictly increasing message IDs

def nonIncreasingIds :=
  filter(generate <= prev(generate), generate)
out nonIncreasingIds

# g) Check that generate produces sequential message IDs

def nonSequentialIds :=
  filter(generate - 1 != prev(generate), generate)
out nonSequentialIds

# h) Check that every generated message ID is eventually processed

def addRemove(add: Option[Int], remove: Option[Int],
    set: Option[Set[Int]]) := {
  def s := getSome(set)
  def added :=
    if isNone(add) then s
    else Set_add(s, getSome(add))
  def removed :=
    if isNone(remove) then added
    else Set_remove(added, getSome(remove))
  return Some(removed)
}
  
def event := merge(generate, process)
def open: Events[Set[Int]] := merge(op, Set_empty[Int])
def op := lift3(generate, process, last(open, event), addRemove)
out open

# i) Compute the average time it took to process a message

def generated: Events[Map[Int, Int]] :=
  merge(gen, Map_empty[Int, Int])
def gen := Map_add(
  last(generated, generate),
  generate,
  time(generate))
def processing := on(
  time(process) - Map_get(generated, process),
  process)
def avgProcessing := sum(processing) / count(processing)
out avgProcessing
